[
  {
    "objectID": "wait-time.html",
    "href": "wait-time.html",
    "title": "Simmer Guide",
    "section": "",
    "text": "How many rolls does it take to get a six?\nOf course, it varies. Sometimes you’ll get a six on your first roll. Sometimes, you will roll and roll until you get one.\nSo we really want to know two things:\n\nWhat is the average number of rolls? (and we suspect the answer is 6)\nWhat is the distribution of the number of rolls?\n\n\n\nHere is a program that does what we want. Notice three new blocks:\n\nInstead of looping a fixed number of times, we have a repeat while block.\nThe repeat while needs a Boolean block (the aDie ≠ 6 clause).\nInside the loop, we use a special change count by block that adds one to our count variable.\n\nWe also have an outer repeat loop that does this whole dance 100 times:\n\nConstruct that program in the live example below, and run it. Make the variables you need. Graph your results, probably collapsing the program so you have enough screen space. What does the distribution of “wait times” look like? Is its mean (about) 6, the way we expect?\n\n\n\nContinue to explore the program and its results.\n\n\n\nThis program introduces a number of new and powerful ideas, such as the whole repeat while thing.\nFor a moment, though, let’s look at something more prosaic: the way we set aDie and count to zero:\nBe sure you understand why we do that, and what alternatives we might have.\nAnd how should you come to that understanding?\nA great way is to change the program. For example, take out the set aDie to 0 statement and run it. What happens? Why?\nIf you are only starting to learn to program, and you try to write this on your own, you might not even think of including that statement! That’s normal. But when your programs don’t work, you’ll soon get used to looking for places where, for example, you didn’t reset your variables.\nFor another way to think about learning programming, see this section about pre-thinking your code.\n\n\n\nTry this: change the repeat while aDie ≠ 6 statement to repeat until aDie = 6. (Use the little menus in the blocks.)\nDo you still need to reset aDie every time? (yes) What’s the difference between repeat while and repeat until?\n\n\n\nOur program makes one CODAP case every time you finally roll a 6. Suppose we wanted to record all of the die rolls, including the final 6.\nHow could we change the program to make that work—and still be able to display that wait-time distribution?"
  },
  {
    "objectID": "examples.html",
    "href": "examples.html",
    "title": "Simmer Guide",
    "section": "",
    "text": "Here are links to a number of more sophisticated examples of simmer programming and the data that they can generate.\nThese all have a particular form, which you might find useful:\n\nThey begin by defining a bunch of variables and giving then initial values.\nThen there is a loop that produces data.\n\nOne way to use the program is to change one or more of the initial values and then run it again. What effect did changing those values have on the results? Why is that?\nOf course, you should make a graph—or two or three—to display your results, and change those graphs as necessary as you learn more.\n\n\nWe often use “Fbola” as the name of a fake disease (like Ebola but Fake). In this simulation, we have a test for the disease, but it’s not perfect.\nYou will see parameters for the accuracy of the test in the program. You might even change the program so that these parameters are variables that get output with the other data.\nThe key Bayesian question you should answer right away is, “If I test positive, what’s the probability that I have the disease?”\n\n\n\n\nA text box in the document describes this important and venerable game.\nOne task is to create an optimal strategy for the game. In this program,a parameter called limit governs when you stop rolling the die. What’s the best value for limit?\nBut there are other possible strategies that don;t involve a limit! Implementing those requires altering the program, or creating a new one altogether.\n\n\n\n\n\nThis is something different: no probability at all.\nInstead, it’s physics: a numerical simulation of projectile motion.\nThis is very unsophisticated, using the bare minimum Euler’s method kind of calculation. No Runge-Kutta! Not even Simpson’s Rule! But it still looks interesting, and we can explore, among other things, how accurate this simple-minded calculation can be."
  },
  {
    "objectID": "loaded.html",
    "href": "loaded.html",
    "title": "Simmer Guide",
    "section": "",
    "text": "So far, we have been rolling fair dice, that is, the probability of each number coming up is the same. What if we want to change that?\nOne way is to artificially give the die more faces. Instead of the set of faces being {1, 2, 3, 4, 5, 6}, we’ll make a die where the set is {1, 2, 3, 4, 5, 6, 6}.\nThis takes a little gruntwork in simmer; here is a picture of the code you need. See if you can figure out how it works:\n\nThink about the consequences of this change and predict:\n\nIf you roll this die 70 times, how many 4’s do you “expect?””\nHow many 6’s?\nSketch (on paper or in your head but don’t skip this!) the graph you might see if you just graphed loadedDie in CODAP.\n\nNow try it in the live example below; roll 70 loaded dice and graph the results:\n\n\n\n\n\n\nTip\n\n\n\nTo get the last block in the second line, “theFaces”, you first have to make the variable theFaces as you learned before.\nThen pull an item block out of Variables and use the menu on it to change the name.\n\n\n\n\n\nAs we saw before, you probably didn’t get a very smooth graph, not too close to the “theoretical” distribution.\nSo keep sampling until you have 700 die rolls. Does that look more like the prediction?\n\n\n\nThink about what would happen of you rolled two loaded dice and added. What would the distribution of that sum look like? (Think first, predict, even make a diagram, then try it.)\nIf you had a die, and you didn’t know if it was loaded, how could you tell? This might be a job for inference!\nYou can use the Make list from text block for more than just loaded dice! Imagine what you could do with this code:\n\n\n\n\n\n\n\n\nHeading towards modeling\n\n\n\nStart to imagine what kinds of things you can simulate. That code, for example, might be part of making a model of a fictitious student body.\n\n\n\n\n\nWe made an intermediate attribute called theFaces. This is an Array, a list of the faces of our die. And we made it using a special, long block you found under Arrays and Lists.\n\nThis block, make list from text, has two arguments:\n\na string containing the list itself, “1,2,3,4,5,6,6” and\nthe delimiter, which is a comma (as a string, so it’s in quotes): “,”.\n\nThe delimiter is the character that separates list items. You could imagine using a dash or even a space as the delimiter…but you can use anything.\nSo theFaces is that whole list. Internally, it’s an Array; it looks like this: [1, 2, 3, 4, 5, 6, 6].\nThen, in the next line, we set loadedDie using a pick from list block, which is in the middle of these three:\n\nYou found this block under Random, because its job is to pick a random item from the list you give it.\nThen you emit the variables into CODAP, 70 times.\nProbably, nothing will appear under theFaces. That’s normal."
  },
  {
    "objectID": "n-dice.html",
    "href": "n-dice.html",
    "title": "Simmer Guide",
    "section": "",
    "text": "You’ve just done 10 dice using this program:\n\nClearly, you could add any number of dice by changing the number 10 in that loop block. Here is a different way to do this:\n\nThe difference is, instead of a number in the loop (“repeat 10 times”) we have a variable (“repeat \\(n\\) times”). Make sure you understand why this program will roll 42 dice and add the results.\nA single run looks like this; your results will vary:\n\nWhy would you want to write it this way?\n\nIf you want to change how many dice get rolled, you can change the number up at the top; you don’t have to search through the code to find the number.\nSince n is a variable in the program, it gets output to CODAP. That is, we know the sum of 140 comes from a roll of 42 dice.\n\n\n\nThat means that you can set up interesting data collection scenarios. For example, suppose we take our program for getting the sum of 42 dice and run it 100 times. That only requires wrapping the program above in a loop to repeat it 100 times.\nBut then suppose we want to do the same thing, but instead of rolling 42 six-sided dice, we roll 21 thirteen-sided dice—and then compare the two distributions.\nThe live example below already has the program for 42 dice, above.\n\nWrap that in a loop to do that 100 times, as described above.\nCollect data so you have 100 cases.\nChange the program to roll 21 13-sided dice (100 times)\nAgain, collect data. Now you have 200 cases—but half of them have n=42 and half have n=21.\nMake a graph that lets you compare the distributions of sums.\n\n\n\n\nHere is our graph. Notice, we had to change n to categorical (Click on the n in the graph to get its menu, then choose Treat as Categorical). Yours will be different, but only because of chance.\n\n\n\n\n\nWith this simulation we can ask at least two interesting questions:\n\nIt looks as if the means are the same. Is that true? Why?\nIt looks as if the standard deviation (the spread) of the “21” graph is larger. Is that really true? (Yes!) How do you know it isn’t just chance? Why is that SD bigger?\n\n\n\n\n\n\n\nThe importance of recording n\n\n\n\nThis bears emphasizing: we could have just put 42 and 21 in the space for how many times to go through the loop. Instead, we made a variable, n, and used that.\nAs a result, every single case had that number in it, and we could use it to separate our two distributions. Without n, we couldn’t put it on that axis!\nAlso: if you know about the “grouping” data move, where you drag an attribute to the left—you can do that with n and then calculate means and spreads.\nThere is yet another reason to do it this way, and you will meet it in the next chapter."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Simmer Guide",
    "section": "",
    "text": "With simmer, you can use block programming to simulate probability experiments, among other things.\nThis guide assumes you have some CODAP skills:\n\nYou can make graphs.\nYou can make a new attribute (a new column) and give it a simple formula.\n\nDo the three lessons you can see in the sidebar.\n\n\nIf you want to experiment outside of this guide, click the link below to open a simmer document in a new tab. You’ll have more space.\nBookmark it so you can simmer again whenever you want."
  },
  {
    "objectID": "ten-dice.html",
    "href": "ten-dice.html",
    "title": "Simmer Guide",
    "section": "",
    "text": "We did one die and two dice. How about three dice? Then, what about ten dice?\nIt’s easy to see how to do three: start with two and make a new variable, die3, and slip it into the program:\n\n\n\nBut when you get up to maybe 10 dice, that’s impractical. You would have to create ten variables, and besides all the trouble that entails, it’s easy to imagine a screwup. Something will go wrong.\nLook at this program and see if you can figure out how it works. It rolls ten dice and adds them, and then emits the sum (rather than the ten individual values):\n\nAfter you think you see how it works, build it in the live example below. Along the way, you should discover that:\n\n\n\n\nThe “zero” block is in the Math category.\nSo is the “addition” block. Note that the “+” is also a menu; if you need subtraction or whatever, make an addition block and change it.\nYou will be using that Create variable…. button a lot!\n\n\n\n\nWhen you run your program once, you should see something like this:\n\n\n\n\n\nThis tells us that the sum of the ten dice was 31. Of course, you can graph theSum and run it many times.\nBut what about aDie? What is that? Look carefully at the program so that you understand that it is the last single die in each set of 10. The program uses that same variable, aDie, ten times every time you run it. And its value when the program hits the send variables to CODAP block is the last of those ten values.\n\n\n\n\n\n\nExtra fun…\n\n\n\nWhat happens when you put the send variables to CODAP block inside the loop? Predict what will happen; then try it and explain what you see!\n\n\nSuppose you’re tired of pressing the run button so many times. If you want to roll 10 dice, and get their sum, 100 times, make your program look like this:\n\nThe key takeaway is this: you can put loops inside loops!\nHere, the two loops have different meanings:\n\nThe inner loop (10 times) is how many dice you roll (and add).\nThe outer loop (100 times) is how many times you roll 10 dice.\n\nTry it up above! Just alter your existing program by wrapping it in a loop! The result should be 100 cases—because the send variables to CODAP block is inside the “100” loop but not inside the “10” loop.\nWe got these graphs. Don’t forget to collapse the Blockly box so you have room to work!\n\n\n\n\n\n\nOne run of 100 reps of adding 10 dice.\n\n\n\n\n\n\n\nTen runs, that is, 1000 rolls of 10 dice.\n\n\n\n\n\nIf you think that the graph of 1000 sets of rolls looks a lot like a Normal distribution, you’re right! It’s not exactly Normal, but it’s really close.\n\n\n\n\n\n\nRidiculously far too advanced. Do not attempt this.\n\n\n\nKnow about grouping? Know your data moves?\nDo 1000 repetitions of 10 dice, summing, as described above. Your table will have a column for aDie, the last die roll from each set of ten.\nGroup the table by aDie and compute the mean value of theSum for each group.\nThen plot that mean against aDie. Explain the result."
  },
  {
    "objectID": "coins.html",
    "href": "coins.html",
    "title": "Simmer Guide",
    "section": "",
    "text": "We have been rolling dice; what about flipping coins?\nIn the Random section of the toolbox, you will see this block:\n\nThis will “emit” either heads or tails with a probability of 1/2. So if you want to flip a coin 20 times and count the number of heads, you might write this program:\n\nMake this program and run it. You can use the live example below; we have littered it with some of the ingredients you will need. Go to the Variables section of the toolbox to make any additional variables.\n\n\n\n\n\nYour data table should look something like this:\n\n\n\n\n\nIn this particular run, there were 8 heads in the 20 tosses of the coin. You can run it repeatedly to see more data.\n\n\n\n\n\n\nHow do you disconnect blocks? How do you delete?\n\n\n\nIt’s obvious how to connect blocks in our “Blockly” window. But it can be a challenge, at first, to disconnect blocks, or generally fix things that go wrong.\n\nIf you drag a block, all of its connected “children” come along…\n…but it gets separated from its parents.\n\nTherefore, if B is under (or to the right of) A, drag B to disconnect them.\n\nTo delete a block, drag it to the trash—or just select it and press the delete key.\n\n\n\n\n\nSee if you can understand the program to do this. How does it work? Here are things to think about and do to make sure you understand it:\n\nThere is a “loop” that runs 20 times. It’s green. What is it for?\nThere is a variable called nHeads. We set its value (0) outside the loop. What would happen if you moved that statement (set nHeads to 0) inside the loop? Try it and see.\nThere is an “if” statement in blue. What does that do?\nWhat would be different if you changed the string in the if statement from \"heads\" to \"tails\"?\nThere is a spot where nHeads gets incremented. What does that mean?\nWhat happens if you eliminate that “increment” statement from the program?\nWhere can you find the if statement in the toolbox?\nThe statement to send variables to CODAP is outside the loop. What would happen if you put it inside the loop? As usual, try it and see!\n\nTry to make it your goal to be able to construct this program (or one like it) without any help. Will you always get it right the first time? No! Of course not! None of us do! But you can run it and see what goes wrong, and fix it. Blockly and CODAP do not care how many tries it takes. They do not judge.\n\n\n\nThe current program flips a fair coin 20 times and records the number of heads. Here are some things to try:\n\nChange the program so that it does those 20 flips … 100 times. That is, a total of 2000 flips, but in sets of 20, counting the number of heads each time. You should wind up with 100 cases in your table, and you can plot a distribution. You can ask, how unusual is it to get 16 heads in 20 tosses?\nChange that program so that the probability of heads is 3/4. Now how unusual is 16 heads?\nMake the probability a variable instead of a constant. Make a simulation that flips a fair coin 400 times and then flips a loaded coin 400 times. Compare the number of heads from the fair coin to the number of heads from the loaded coin. Do a randomization test to see if it’s plausible that the difference you see could arise by chance."
  },
  {
    "objectID": "one-die.html",
    "href": "one-die.html",
    "title": "Simmer Guide",
    "section": "",
    "text": "We will begin by rolling one die\nMake the program you see below. Notice how the blocks fit together. We have a block that represents a variable (named item), and it “receives” a random number. Then we send that data to CODAP.\n\n\n\n\n\nIn the live example below, try to build that program. Some hints:\n\nThe gray stripe on the left is called the toolbox.\nThe toolbox contains the names of categories. Click on a name to see the blocks in that category.\nIn the Variables category, you will need to create a new variable called die.\nFind the blocks you need in three different categories.\nDrag blocks from the toolbox into the main workspace and hook them together.\nIf you get one you don’t want, you can drag it to the trash can in the lower right.\n\nSee how you do:\n\n\n\nWhen you have it the way you want, press the run button (the green circle). A CODAP table appears with your data in it. Run the program a few more times and see how the value of item changes.\nBecause it’s in CODAP, you can make a graph the usual way.\n\n\n\nDoes item look evenly distributed? (Probably not!)"
  },
  {
    "objectID": "commentary-redux.html",
    "href": "commentary-redux.html",
    "title": "Simmer Guide",
    "section": "",
    "text": "Let’s look back at the “wait-time” program, where we wanted to know how many die rolls it would take to get a six. Here is an example of how to think about the program: imagine what you would do if you were collecting data with an actual die.\n\n\nWe will not always demonstrate this business of thinking about the program in English instead of in code. But it’s a good habit-of-mind for you and for your students.\n\nRoll the die and see what number it is.\nIf it’s a six, you’re done.\nOtherwise, go back to step 1.\n\n\n\nPeople often say that a program written this way is in “pseudocode”.\nWait—that’s not enough! We need to count the number of rolls. We’ll use a tally to count them:\n\nRoll the die and see what number it is.\nIf it’s a six, you’re done.\nOtherwise, make a tally mark.\nGo back to step 1.\n\nNo, wait: If I roll a five and then a six, that’s two rolls, but I’ll only make one tally mark. (Make sure you see why!) We’ll fix that by switching steps 2 and 3, with an appropriate change in logic:\n\nRoll the die\nMake a tally mark.\nIf the die does not show a six, go back to step 1.\nOtherwise, you’re done.\n\nThat’s better, but to get a distribution, we’ll need to do this many times. Like 100. And when we’ve done that, we’ll need the numbers of how many rolls it took each time, so we had better write them down.\n\nDo the following 100 times:\n\nRoll the die\nMake a tally mark.\nIf the die does not show a six, go back to step 1.\nOtherwise,\n\nwrite down the number of tallies\nerase the tallies\nstart over\n\n\n\nNotice how each version gets better as we figure out what went wrong. Try to think through what will happen before you go to the computer, but don’t overdo it: the computer will execute your instructions faithfully, and when it gives you a wrong answer, you will see what you have to do to fix it.\nNow, recall the Blockly code (below). See if you can tell exactly what blocks correspond to which parts of our “pseudocode”:\n\nInterestingly, the set aDie to 0 block has no corresponding pseudocode. And yet it’s essential! I think this is a good example of how doing simulations on a computer is different from real life."
  },
  {
    "objectID": "two-dice.html",
    "href": "two-dice.html",
    "title": "Simmer Guide",
    "section": "",
    "text": "One die is great…but what could be better? Two dice! More than twice as good.\nWe give you a fresh, blank simmer document below. You can start fresh right there or modify what you did above. Try to make a program like this one:\n\n\n\n\n\n\n\nNames are important\n\n\n\nGive your variables meaningful names. Names like die1 and die2 tell you what’s going on.\n\n\nHere are some tips:\n\n\n\n\nGo to the Variables part of the toolbox and press Create variable… to make the variables die1 and die2.\nSee the illustration on the right? After you make a block that sets a variable, you can use the menu in that variable block to change which variable it refers to. You can also use that menu to change the variable’s name.\n\n\n\n\nWhen you run your program, simmer will create a column in your CODAP table for every variable in your program. That means you can calculate the sum of the two dice in CODAP.\n\nmake a new column with a formula for the sum of the two dice.\nmake a graph of that sum.\n\nIf you know the theory, you know it’s suppose to look like a pyramid. Does it look the way you expect? Is seven the most popular sum?\nIf not, add a few hundred cases. See if it gets closer to the “official” result.\nNow for something really cool:\n\nImagine a graph with die1 plotted against die2. Stop and think: what will that graph look like?\nMake a new graph and do that plot. Did it look the way you expected?\n\nDid you collapse your code so that you could see the graph better? Don’t forget that tip!\n\nIn the graph of sum, select all the cases with a sum of 5.\n\nYour screen might now look something like this:\n\n\nLook at the other graph, and think about what that means. Use selection in this way to make a convincing argument why seven is the most common result, and why 2 and 12 are the rarest.\n\n\n\nYou made a probability model using simmer, simulating throws of two dice.\nUsing a “repeat” block—a loop structure—you could throw lots of dice, many more than would be practical in real life.\nFinally, you used the results to learn more about how probability works."
  },
  {
    "objectID": "repeating.html",
    "href": "repeating.html",
    "title": "Simmer Guide",
    "section": "",
    "text": "Let’s change the program so that it repeats that process on its own, so that we don’t have to press the button so many times.\nImprove the example below.\n\nFind a “repeat” block in one of the categories that will run those blocks 10 times.\nDrag it into the workspace and make it enclose the blocks you want to repeat.\nRun it and see what happens. (It’s probably still not very evenly distributed.)\nChange the number of repeats to a few hundred and run it again.\nSee if the graph shows that item has a more even distribution.\n\n\n\n\nThe screen is getting crowded. It’s hard to work with the program, the graph, and the table at the same time.\n\n\n\n\n\n\npro tip: collapsing the code\n\n\n\nIn the simmer top bar you’ll see a [currently brown] square  showing four arrows pointing inward. Press it to collapse the program so you have more space for data analysis.\nThen, when you want to program again, press the button to give yourself room to code.\n\n\n\n\n\n\n\n\nThe answer, in case you get lost"
  },
  {
    "objectID": "basics-commentary.html",
    "href": "basics-commentary.html",
    "title": "Simmer Guide",
    "section": "",
    "text": "The three brief lessons you just did are a great start to learning simmer and learning to simulate probability situations.\nAs a teacher, you can now imagine a variety of questions and tasks for students that use only those skills—and CODAP basics. For example:\n\nWhat is the average value of a single die roll? How do you know?\nWhat is the probability that you roll a 10 with two regular dice? Give an empirical value you find through simulation and, if you can, a theoretical value you figure out through logic.\nWrite a program for a special die whose average value is zero, but where the spread of possible values is more than 5.\nWhat is the most likely number to come up if you roll two 8-sided dice and add? Why?\nWrite a program for rolling two dice, where the average value for the sum is zero, but the average value for either of the individual dice is not zero.\n\nIf you teach traditional statistics, you can also imagine assigning students to perform tests and estimates using data from these simulations. For example:\n\nAloysius says, “The maximum value for one die is six. So therefore the mean value is three.” He rolls a die ten times and gets a mean value of 3.1, so he is satisfied that he is correct. He is wrong, of course. Try testing the hypothesis that \\(\\mu_0 = 3.0\\) with various sample sizes. How many rolls did you need to reject that hypothesis fairly consistently?\n\n\n\nYou can do even more with simmer, using new blocks and techniques to create more types of simulations.\nYou can figure these out for yourself by shopping around in the various catgories of blocks and trying them out. You can also read about some of them in the next few pages.\nThen, at the end, we give you some examples of more elaborate simulations."
  },
  {
    "objectID": "functions.html",
    "href": "functions.html",
    "title": "Simmer Guide",
    "section": "",
    "text": "This builds directly on the n-dice chapter, so check that out if you haven’t read it.\nIn that chapter, we used this program to roll 42 6-sided dice and add them—100 times:\n\n\n\n\n\nNow we will learn how to “encapsulate” that program into a single statement. We’ll define a function to do that.\n\nWe’ll get a function definition from the Functions category in the toolbox. It’s the top item, labeled to do something. (See the illustration at right.)\n\n\n\n\n\nWe’ll wrap that definition around the statements we want in the function (the same way we wrapped statements in loops).\nFinally, we’ll edit do something to give the function a dood name, such as “roll 6 x 42, 100 times.”\n\nIt will look like this when you’re done:\n\n\n\n\n\nThis function definition is not part of the program that simmer executes until you call it. But when you do, the actual program becomes amazingly simple and understandable.\nTo get the call, go back to the Functions category. Drag out the function “call” block, which has only the function’s name. It looks like this:\n\n\n\n\n\nAnd that is the entire program! So the block window will have two things in it: the function definition (which is long and details) and the program that call it (which is short and more general).\nIn the last chapter, we also rolled 21 13-sided dice. you will put those instructions into a very similar function called roll 13 x 21, 100 times.\nYour turn. Using the live example below,\n\nWrap the code in a loop so you roll those 42 dice 100 times.\nDefine the first (6-sided die) function as we did above\nSelect the definition (just click on the “wrapper”) and copy it to the clipboard.\nPaste the definition into your workspace (now there are two copies).\nChange its name and its instructions to roll 21 13-sided dice 100 times.\nBring two blocks out of Functions to call those two functions and hook them together\nRun the program and make a graph of the data. It should look the way it did before!\n\n\n\n\n\n\nThat was sweet, but as you can see, the two functions are almost identical. The loops and everything are structured the same. There are only two differences:\n\nThe number of rolls (42 and 21) (we’ll call it nRolls)\nThe number of sides of each die (6 and 13) (nFaces)\n\nLet’s write one function to take care of both situations. It will look like this. Notice that it is exactly like the original function except that two of the constants in the original function are now variables:\n\n\nThis function has two arguments, nRolls and nFaces (indicated by the with at the top).\nIt uses those two arguments in the program,\n\nnRolls as the number of times through the inner loop.\nnFaces as the number of faces on the dice.\n\nThe function repeats the rolling-and-summing bit 100 times, sending data to CODAP every time through the outer loop.\n\nNow the actual program becomes amazingly simple and understandable. Here it is:\n\n\n\n\n\n\n\n\nHow did we get those arguments?\n\nClick on the little gear in the function definition block. A dialog will appear. \nDrag the input name: x to the inputs bracket on the right. Do this twice; two arguments. Edit the names there. Make them nRolls and nFaces.\nClick the gear again to make the box go away.\nDrag nRolls and nFaces out of Variables and substitite them in the appropriate places in the function definition.\n\nTry it in the live example below (be sure to give the function a name, and don’t forget the loop to repeat 100 times!):\n\n\n\n\n\n\n\n\n\nSuper advanced….\n\n\n\nOnce you have a function defined, it takes up a lot of space. If you’re confident it’s the way you want it:\n\nRight-click on the function definition.\nChoose Collapse block.\n\nThis works with any block! Try it!"
  }
]